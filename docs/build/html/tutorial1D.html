
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="English">
  <head>
    <meta charset="utf-8" />
    <title>Tutorial: 1D SPDE modeling using Fieldosophy &#8212; Fieldosophy 0.1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fieldosophy API" href="api_reference.html" />
    <link rel="prev" title="Tutorials" href="tutorials.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api_reference.html" title="Fieldosophy API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fieldosophy 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tutorials.html" accesskey="U">Tutorials</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial-1d-spde-modeling-using-fieldosophy">
<h1>Tutorial: 1D SPDE modeling using Fieldosophy<a class="headerlink" href="#tutorial-1d-spde-modeling-using-fieldosophy" title="Permalink to this headline">¶</a></h1>
<p>This tutorial explains the basics of modeling a Gaussian random field in one dimension using the SPDE-approach.
Let us consider modeling a continuously indexed Gaussian random field in one dimension on the interval [0,1] of the real line using the SPDE approach.
Since we are using a FEM approximation we first need to specify a simplicial mesh over the domain of interest.</p>
<div class="section" id="constructing-the-mesh">
<h2>Constructing the mesh<a class="headerlink" href="#constructing-the-mesh" title="Permalink to this headline">¶</a></h2>
<p>A simplicial mesh is made up of nodal points and corresponding simplices.
The nodal points, for a one-dimensional mesh, are defined as an array of size N x 1 where 'N' is the number of nodal points and the value at the i:th element of the array is the location of the i:th nodal point.
For this example, let us define 500 nodal points evenly distributed over the unit interval using the numpy 'linspace' command.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">500</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>For one-dimension, a simplex is a line between two nodes. The simplices are therefore defined in an array of size NT x 2, where each row defines a simplex by giving the indices of its two nodal points.
To make a sensible mesh in one-dimension we want the nodal points to be connected through a simplex with the former and next nodal point on the interval.
Since our nodal points are in the order from lowest to highest, we can make such a collection of simplices by stacking two one-dimensional arrays, one with values from 0 to N-1 and one from 1 to N.
Since the available indices of the nodal points ranges from 0 to N-1, we can construct the simplices using the 'arange' command from numpy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">simplices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">499</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">500</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>Given the nodal points and simplices we create a mesh object using the 'Mesh' class from fieldosophy.mesh.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fieldosophy</span> <span class="kn">import</span> <span class="n">mesh</span> <span class="k">as</span> <span class="n">mesher</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">mesher</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">simplices</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="constructing-a-matern-model">
<h2>Constructing a Matérn model<a class="headerlink" href="#constructing-a-matern-model" title="Permalink to this headline">¶</a></h2>
<p>If we want to work with the Matérn model on the defined mesh we first want to choose the values of the parameters.
The general Matérn model has three parameters, a range parameter (<span class="math notranslate nohighlight">\(\kappa\)</span>), a smoothness parameter (<span class="math notranslate nohighlight">\(\nu\)</span>), and a marginal standard deviation parameter (<span class="math notranslate nohighlight">\(\sigma\)</span>).
In the <em>MaternFEM</em> class of Fieldosophy.FEM we actually parameterize the range by the, more intuitive, correlation range <span class="math notranslate nohighlight">\(\left( r := \frac{\sqrt{8\nu}}{\kappa} \right)' instead of :math:\)</span>kappa`.
Let us set the correlation range to 0.4, the smoothness to 1.5, and the marginal standard deviation to 2. We can then create the Matérn FEM object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the Matérn random field</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># Set correlation range (range for which two points have approximately 0.13 correlation)</span>
<span class="n">nu</span> <span class="o">=</span> <span class="mf">1.5</span>   <span class="c1"># Set smoothness (basically the Hölder constant of realizations)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span>   <span class="c1"># Set standard deviation</span>
<span class="c1"># Create MaternFEM object</span>
<span class="kn">from</span> <span class="nn">fieldosophy.GRF</span> <span class="kn">import</span> <span class="n">FEM</span>
<span class="n">fem</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="p">)</span>
</pre></div>
</div>
<p>Notice how <em>sigma</em> and <em>nu</em> are direct parameters to FEM.MaternFEM while <em>r</em> is a member of the dictionary <em>childParams</em>, which itself is a parameter of FEM.MaternFEM. The reason for this is that <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\nu\)</span> are parameters of the general differential operator of <a class="reference internal" href="introduction.html#equation-hildemanspde">(3)</a>, while <span class="math notranslate nohighlight">\(r\)</span> is a parameter of the differential operator of <a class="reference internal" href="introduction.html#equation-lindgrenspde">(2)</a>.
Since <a class="reference internal" href="introduction.html#equation-lindgrenspde">(2)</a> is just a special case of <a class="reference internal" href="introduction.html#equation-hildemanspde">(3)</a>, the <em>r</em> parameter is added to the FEM.MaternFEM class while the <em>nu</em> and <em>sigma</em> parameters are actually added to a class higher up in the inheritance hierarchy.</p>
<p>We can now generate realizations of our Matérn Gaussian random field on [0,1]. Let us generate two realizations at the nodal points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Acquire realizations on nodes</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">generateRandom</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span>
</pre></div>
</div>
<p>And plot these using matplotlib.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot realizations</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 1&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 2&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1K1zWpkfYvykeWN5rEpx40JYpydHPWEmI"><img alt="https://drive.google.com/uc?export=view&amp;id=1K1zWpkfYvykeWN5rEpx40JYpydHPWEmI" src="https://drive.google.com/uc?export=view&amp;id=1K1zWpkfYvykeWN5rEpx40JYpydHPWEmI" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1I8Vse1okxEqAP2DMVNWY9lAz0fnAvSRU"><img alt="https://drive.google.com/uc?export=view&amp;id=1I8Vse1okxEqAP2DMVNWY9lAz0fnAvSRU" src="https://drive.google.com/uc?export=view&amp;id=1I8Vse1okxEqAP2DMVNWY9lAz0fnAvSRU" style="width: 49%;" /></a>
<p>As can be seen, we have two different functions on the unit interval.
Both of them are exhibiting a correlation range of 0.4; which is indicated by all trends having a length of no more than approximately 0.4.</p>
</div>
<div class="section" id="quality-of-fem-approximation-and-numerical-stability">
<h2>Quality of FEM-approximation and numerical stability<a class="headerlink" href="#quality-of-fem-approximation-and-numerical-stability" title="Permalink to this headline">¶</a></h2>
<p>It should be noted that the smoothness parameter (<span class="math notranslate nohighlight">\(\nu\)</span>), the range (<span class="math notranslate nohighlight">\(r\)</span>), and the number of nodes (N) per distance all together strongly affects how well the FEM solution approximates the theoretical random field.
As a rule of thumb, there should be at least 5 nodes per correlation range.
That means that, anywhere on the mesh, one has to pass atleast 5 nodes when moving a distance corresponding to <span class="math notranslate nohighlight">\(r\)</span>.
The reason for this is that the finite element approximation of the true solution otherwise becomes bad.</p>
<p>How many nodes per correlation range one should have to get a good approximation depends on several factors:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Piecewise linear basis functions</dt><dd><p>The FEM-approximation assumes that the realizations are piecewise linear (linear within a simplex), considering several points within the same simplex, for the same realization, can only give you a linear relationship between them.
Hence, it is often necessary to have a closer space between nodes in regions where there are a lot of observation points.
This such that there should be no more than one observed point in the same simplex (in the same realization).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Demand on approximative power</dt><dd><p>How similar the correlation function should be to the theoretical one (Matérn in this case) depend on the application.
Therefore, the number of nodes per correlation range should be adjusted for your needs.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Computational cost</dt><dd><p>More nodes means a higher computational cost. In one dimension the computational cost (of the FEM approximation) is linear in the number of nodes.
In higher dimensions it is larger ( <span class="math notranslate nohighlight">\(\mathcal{O}^{\frac{2}{3}}\)</span> for two dimensions and more than quadratic for three-dimensions).
Therefore, one does never want to have more nodes in the mesh than what is needed.</p>
</dd>
</dl>
</li>
</ol>
<p>Our personal experience is that 7-12 nodes per correlation range is usually sufficient for the applications we have encountered.</p>
<p>Another issue is numerical stability. This can be a problem if 'N' is very large.
More than so though, numerical stability is strongly affected by the smoothness parameter (<span class="math notranslate nohighlight">\(\nu\)</span>).
The reason is twofold:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Number of FEM-approximations</dt><dd><p>A FEM approximation is actually only made on the stochastic partial differential equation of <a class="reference internal" href="introduction.html#equation-generalspde">(1)</a> with <span class="math notranslate nohighlight">\(\beta = 1\)</span>.
For every other value of <span class="math notranslate nohighlight">\(\beta\)</span>, the approximation is made by doing FEM approximations on the FEM approximation, i.e., <em>iterated FEM</em>.
For instance, <span class="math notranslate nohighlight">\(\beta = 3\)</span> means that two levels of FEM approximations are made while <span class="math notranslate nohighlight">\(\beta=5\)</span> means that three levels of FEM approximations are made.
For every level of FEM approximation, the resulting precision matrix becomes less stable, i.e., instabilities propagate and amplifies for each iteration.
In Fieldosophy, the maximum number of iterations allowed are 2, i.e., no more than two levels of FEM approximations can be performed, regardless of <span class="math notranslate nohighlight">\(\beta\)</span>.
The limit of 2 is to reduce this issue of propagating instabilities.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Rational approximation</dt><dd><p>Remember that <span class="math notranslate nohighlight">\(\beta = \frac{\nu}{2} + \frac{d}{4}\)</span> and <span class="math notranslate nohighlight">\(\nu\)</span> can be any positive value.
For the cases when <span class="math notranslate nohighlight">\(\beta\)</span> is not an integer (or due to the limit of 2, also when <span class="math notranslate nohighlight">\(\beta\)</span> &gt; 3), the approximation to the solution is a linear combination of several (iterated-) FEM approximations, see <span id="id1">[<a class="reference internal" href="bibliography.html#id4"><span>BK19</span></a>]</span>.
Although no single iterated FEM approximation in this case has a higher level than 2, they are summed up with varying values of coefficients.
For some combinations of these coefficients (each combination corresponding to a single value of <span class="math notranslate nohighlight">\(\beta\)</span>), the precision matrix can become unstable.
This is typically the case for small values of <span class="math notranslate nohighlight">\(\beta\)</span>, i.e., small values of <span class="math notranslate nohighlight">\(\nu\)</span>.</p>
</dd>
</dl>
</li>
</ol>
<p>Hence, one should be aware that small values of <span class="math notranslate nohighlight">\(\nu\)</span> can give a worse approximation of the theoretical covariance function.
In worst case, the precision matrix might actually become so unstable that the Choelsky factorization fails, throwing the error &quot;PositiveDefiniteException: Matrix is not positive definite&quot;.
If you are experiencing instabilities, one remedy can be to reduce the number of nodes in the mesh, if the application allows. A more obvious solution, if the application allow, is to increase <span class="math notranslate nohighlight">\(\nu\)</span>.</p>
<p>To complicate it further, the stability of the precision matrix can also be strongly affected by the boundary conditions.
Especially Dirichlet boundary conditions that are improbable with the given random field model can cause strong instabilities and cause the system to throw the error &quot;PositiveDefiniteException: Matrix is not positive definite&quot;.</p>
</div>
<div class="section" id="boundary-conditions">
<h2>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>So far we have one problem though. In both realizations we see that time series near the ends of the unit interval is going flat.
This is due to the homogeneous Neumann boundary condition that we implicitly enforced on the random field when we generated the FEM.MaternFEM object.
Remember (see <a class="reference internal" href="introduction.html#introduction"><span class="std std-ref">Introduction</span></a>) that the solution to a differential equation is not well-defined without boundary/initial conditions.
In other words, one has to give some kind of condition to even consider a solution to a stochastic partial differential equation.
In the FEM implementation in Fieldosophy this causes any SPDE-model without an explicit boundary condition to get a homogeneous Neuman condition on the whole boundary domain.
In this one-dimensional case, the boundary domain is the end points of the unit interval and the Neumann boundary condition states that the derivative at the boundary should be zero.
This is also something we can observe in the figures above.</p>
<p>It is possible to change the boundary conditions. The supported types of boundary conditions are <em>Dirichlet</em>, <em>periodic</em>, and <em>Robin</em>, where <em>Neumann</em> is a special case of a Robin boundary condition.
Different boundary conditions can also be applied to different parts of the boundary.
In fact, the Dirichlet boundary condition does not even need to be set on the boundary. It is possible to set Dirichlet conditions on any nodes in the mesh, i.e., fixing their values.
However, the Robin and periodic conditions can only be set at the boundaries.</p>
<p>Just to show how this is done, let us apply a Dirichlet boundary condition of 3 to the left boundary and enforce that the 300:th node in the mesh is -0.5, while keeping the homogeneous Neumann boundary condition on the right boundary.
This is done by defining the <em>BCDirichlet</em> parameter when creating the fem object. The BCDirichlet parameter should be an array the size of the number of nodal points in the mesh.
Each element in the array correspond to the Dirichlet condition on the associated nodal point.
A value of 'np.nan' signals no Dirichlet condition on that specific node.
Hence, we can apply our new boundary conditions as,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Dirichlet boundary condition</span>
<span class="n">BCDirichlet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
<span class="n">BCDirichlet</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
<span class="c1"># Create new fem model</span>
<span class="n">fem2</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">BCDirichlet</span> <span class="o">=</span> <span class="n">BCDirichlet</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span> <span class="p">)</span>
</pre></div>
</div>
<p>We can now generate two new realizations and plot these.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Acquire realizations on nodes</span>
<span class="n">Z2</span> <span class="o">=</span> <span class="n">fem2</span><span class="o">.</span><span class="n">generateRandom</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 1 with Dirichlet conditions&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 2 with Dirichlet conditions&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1V-nEqLrActie2YibSniR21NMj-WehqMH"><img alt="https://drive.google.com/uc?export=view&amp;id=1V-nEqLrActie2YibSniR21NMj-WehqMH" src="https://drive.google.com/uc?export=view&amp;id=1V-nEqLrActie2YibSniR21NMj-WehqMH" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=10dElv8qiJr9xLWxZ6pOeFGgGtNkNk18m"><img alt="https://drive.google.com/uc?export=view&amp;id=10dElv8qiJr9xLWxZ6pOeFGgGtNkNk18m" src="https://drive.google.com/uc?export=view&amp;id=10dElv8qiJr9xLWxZ6pOeFGgGtNkNk18m" style="width: 49%;" /></a>
<p>As can be seen, the Dirichlet boundary conditions are indeed enforced in the realizations while the homogeneous Neumann boundary condition still applies to the right boundary.</p>
<p>We know that we will only have a true Matérn covariance function on the unit interval if we extend the modeled domain to the whole real line.
Of course, practically we do only need to extend it a bit outside of the unit interval to get a good approximation of a Matérn covariance function on the whole unit interval.
The amount of extension needed depends on the smoothness and range parameters but also on the boundary conditions.
A rule of thumb is that the extension outside of the spatial domain of interest should be about 1.5 to 2 times the correlation range when using homoegeneous Dirichlet conditions and a centered Gaussian random field (a mean function that is zero).
A similar extension range also apply to Neumann conditions.</p>
<p>It is quite intuitive to think that if we enforce the values at the boundary (Dirichlet condition) the variations around the boundary will be small.
Hence, close to the boundary we will get artifacts (as compared to a Matérn field).
In the same way, enforcing the derivative to be fixed close to the boundary also causes restrictions on the variability.
This since points close to the boundary all tend to have an almost deterministic relationship among themselves (since they should approximately follow the line of the derivative).
Due to this, our experience have shown that one can acquire a shorter range from the boundary artifacts if one instead uses a more clever boundary condition.
If we do not want to put a cap on the derivative (as in a Neumann condition) and we do not want to put a cap on the actual value (as in the Dirichlet condition), we can instead enforce a certain Robin condition.</p>
<p>A Robin condition on a piece of a boundary, <span class="math notranslate nohighlight">\(\Gamma\)</span>, is,</p>
<div class="math notranslate nohighlight" id="equation-robinbc">
<span class="eqno">(1)<a class="headerlink" href="#equation-robinbc" title="Permalink to this equation">¶</a></span>\[\boldsymbol{n} \cdot \nabla X  = a X + b, \boldsymbol{s} \in \Gamma.\]</div>
<p>By setting <span class="math notranslate nohighlight">\(b=0\)</span> and <span class="math notranslate nohighlight">\(a = -1\)</span>, we are saying that the derivative can vary, and the function value can vary to.
We do however force them to vary together such that the derivative is equal to the negative of the actual value.
This means that there will still be boundary artifacts but their effective range is diminished.
In our experience it is sufficient to extend by only 1 times the correlation range when using such a boundary condition.
One might also want to adjust the magnitude of 'a' depending on the smoothness and the marginal variance at the boundary.
The reason being that one might otherwise cap the values of either its derivative or the random field itself.</p>
<p>An arbitrary Robin boundary condition can be defined by the BCRobin parameter. The number of rows of the array should correspond to the number of simplices at the edges.
Each row is associated with a specific boundary simplex, which one can be seen by the command 'mesh.getBoundary()[&quot;edges&quot;]'.
The first column in 'BCRobin' correspond to the <span class="math notranslate nohighlight">\(b\)</span>-value in <a class="reference internal" href="#equation-robinbc">(1)</a>. To set the boundary condition on the right boundary as suggested above, we do:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Robin boundary condition</span>
<span class="n">BCRobin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="n">BCRobin</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Association with constant</span>
<span class="n">BCRobin</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Association with function</span>
<span class="c1"># Update new fem model</span>
<span class="n">fem3</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">BCDirichlet</span> <span class="o">=</span> <span class="n">BCDirichlet</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span> <span class="p">)</span>
</pre></div>
</div>
<p>And once again, generate two realizations and plot these.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Acquire realizations on nodes</span>
<span class="n">Z3</span> <span class="o">=</span> <span class="n">fem3</span><span class="o">.</span><span class="n">generateRandom</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 1 with Dirichlet and Robin conditions&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 2 with Dirichlet and Robin conditions&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1bGdeZos4EXO9GQjVWKt7e-7X9iRzLXKQ"><img alt="https://drive.google.com/uc?export=view&amp;id=1bGdeZos4EXO9GQjVWKt7e-7X9iRzLXKQ" src="https://drive.google.com/uc?export=view&amp;id=1bGdeZos4EXO9GQjVWKt7e-7X9iRzLXKQ" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1iexPdE0mAqBbrKSs-ZlnA-K4EBKGt0fp"><img alt="https://drive.google.com/uc?export=view&amp;id=1iexPdE0mAqBbrKSs-ZlnA-K4EBKGt0fp" src="https://drive.google.com/uc?export=view&amp;id=1iexPdE0mAqBbrKSs-ZlnA-K4EBKGt0fp" style="width: 49%;" /></a>
<p>As can be seen, this Robin condition forces the realizations to have a derivative on the right boundary that is aimed towards zero. That is, a realization that is above zero at 1 will have a tendency to move towards zero and a realization that is below zero at 1 will have a tendency to move towards zero as well.
Note that, if we would place a Robin condition and a Dirichlet condition affecting the same part of the boundary, the Dirichlet condition has presedence.</p>
<p>It should be noted that in this example we used <span class="math notranslate nohighlight">\(\nu = 1.5\)</span>. This was not a coincidence since that corresponds to <span class="math notranslate nohighlight">\(\beta = 1\)</span> in <a class="reference internal" href="introduction.html#equation-generalspde">(1)</a>. In fact, the boundary conditions given are only exact as long as <span class="math notranslate nohighlight">\(\beta = 1\)</span>.
This is because we are using an iterative finite element solution for other values of <span class="math notranslate nohighlight">\(\beta\)</span>.
This means that we will generate the system matrix of the finite element several times. Each time we will enforce the boundary conditions.
Hence, this will generally correspond to a different boundary condition on the final random field then what was given to the &quot;single&quot; FEM solution.
However, using a Robin condition to reduce the extension of the boundary artifacts, as suggested above, still apply and is strongly recomended.</p>
</div>
<div class="section" id="extending-the-mesh-to-remove-boundary-artifacts">
<h2>Extending the mesh to remove boundary artifacts<a class="headerlink" href="#extending-the-mesh-to-remove-boundary-artifacts" title="Permalink to this headline">¶</a></h2>
<p>So given the above we will have to redo our mesh in order to incorporate this mesh extension.
When we extend we might still want to keep the nodal density. Hence we have to increase N accordingly.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create new mesh extended by r in each direction</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="mi">500</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span> <span class="mi">0</span><span class="o">-</span><span class="n">r</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">,</span> <span class="n">N</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">simplices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
<span class="n">extendedMesh</span> <span class="o">=</span> <span class="n">mesher</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">simplices</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span> <span class="p">)</span>
</pre></div>
</div>
<p>Then we create a new FEM object, but this time with the new mesh and with the suggested Robin boundary conditions on both boundary points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create new mesh extended by r in each direction</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="mi">500</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span> <span class="mi">0</span><span class="o">-</span><span class="n">r</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">,</span> <span class="n">N</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">simplices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
<span class="n">extendedMesh</span> <span class="o">=</span> <span class="n">mesher</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">simplices</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span> <span class="p">)</span>

<span class="c1"># Create Robin boundary condition</span>
<span class="n">BCRobin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="n">BCRobin</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Association with constant</span>
<span class="n">BCRobin</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Association with function</span>

<span class="c1"># Create fem model</span>
<span class="n">fem4</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">extendedMesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span> <span class="p">)</span>
</pre></div>
</div>
<p>Let us generate two realizations and plot these to compare.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Acquire realizations on nodes</span>
<span class="n">Z4</span> <span class="o">=</span> <span class="n">fem4</span><span class="o">.</span><span class="n">generateRandom</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z4</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 1 with extended mesh&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Z4</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Realization 2 with extended mesh&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1F2uZadDFnEadSd-qGLPXS_DHovqOrUqB"><img alt="https://drive.google.com/uc?export=view&amp;id=1F2uZadDFnEadSd-qGLPXS_DHovqOrUqB" src="https://drive.google.com/uc?export=view&amp;id=1F2uZadDFnEadSd-qGLPXS_DHovqOrUqB" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1XLT_7Spygb2rGiR6P6tdfDMce032ACIe"><img alt="https://drive.google.com/uc?export=view&amp;id=1XLT_7Spygb2rGiR6P6tdfDMce032ACIe" src="https://drive.google.com/uc?export=view&amp;id=1XLT_7Spygb2rGiR6P6tdfDMce032ACIe" style="width: 49%;" /></a>
<p>Not much new except that the x-axis not show values in the range of [-0.4 to 1.4].</p>
</div>
<div class="section" id="computing-and-comparing-covariances">
<h2>Computing and comparing covariances<a class="headerlink" href="#computing-and-comparing-covariances" title="Permalink to this headline">¶</a></h2>
<p>It would be interesting to compute the actual covariance function and see if it does indeed correspond to a Matérn covariance.
This is possible but remember, a covariance function takes two arguments.
Since the Matérn covariance is stationary it does not matter which two points we choose; the covariance should only depend on the distance between the two points.
Therefore, let us choose one point and compute the covariance between that point and all other points in the mesh.</p>
<p>We choose the nodal point with index 500, that happens to be placed at 0.601.
To acquire the covariance between all nodal points and the point at 0.601 we can use the function 'multiplyWithCovariance' in the FEM class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">referenceNode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">extendedMesh</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">referenceNode</span><span class="p">[</span><span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">covSPDE</span> <span class="o">=</span> <span class="n">fem4</span><span class="o">.</span><span class="n">multiplyWithCovariance</span><span class="p">(</span> <span class="n">referenceNode</span> <span class="p">)</span>
</pre></div>
</div>
<p>We can compare this to the true Matern covariance by using the 'Fieldosophy.GRF.GRF.MaternCorr' function. Remember that the distance should be computed from the nodal point at index 500.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compare with actual matern covariance</span>
<span class="kn">from</span> <span class="nn">fieldosophy.GRF</span> <span class="kn">import</span> <span class="n">GRF</span>
<span class="n">covMatern</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">GRF</span><span class="o">.</span><span class="n">MaternCorr</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">500</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">/</span><span class="n">r</span> <span class="p">)</span>

<span class="c1"># Plot covariances</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covSPDE</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;SPDE&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">500</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Covariance between point 0.601 and all other&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covMatern</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Matern&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=114kj9MGS0GTCNC2kYjWp4GT1jZ53FsmA"><img alt="https://drive.google.com/uc?export=view&amp;id=114kj9MGS0GTCNC2kYjWp4GT1jZ53FsmA" class="align-center" src="https://drive.google.com/uc?export=view&amp;id=114kj9MGS0GTCNC2kYjWp4GT1jZ53FsmA" style="width: 80%;" /></a>
<p>As can be seen, the two plots fit perfectly.</p>
<p>We can compare this with the covariances if we would not have extended the mesh and left the original homogeneous Neumann boundary conditions.
Here using the two different nodal points to see the effect.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute covariance</span>
<span class="n">referenceNode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">referenceNode</span><span class="p">[</span><span class="mi">300</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">covSPDE</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">multiplyWithCovariance</span><span class="p">(</span> <span class="n">referenceNode</span> <span class="p">)</span>

<span class="c1"># Compare with actual matern covariance</span>
<span class="kn">from</span> <span class="nn">fieldosophy.GRF</span> <span class="kn">import</span> <span class="n">GRF</span>
<span class="n">covMatern</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">GRF</span><span class="o">.</span><span class="n">MaternCorr</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">300</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">/</span><span class="n">r</span> <span class="p">)</span>

<span class="c1"># Plot covariances</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covSPDE</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;SPDE&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">300</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Covariance between point 0.601 and all other&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covMatern</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Matern&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="c1"># Compute covariance</span>
<span class="n">referenceNode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">referenceNode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">covSPDE</span> <span class="o">=</span> <span class="n">fem</span><span class="o">.</span><span class="n">multiplyWithCovariance</span><span class="p">(</span> <span class="n">referenceNode</span> <span class="p">)</span>

<span class="c1"># Compare with actual matern covariance</span>
<span class="kn">from</span> <span class="nn">fieldosophy.GRF</span> <span class="kn">import</span> <span class="n">GRF</span>
<span class="n">covMatern</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">GRF</span><span class="o">.</span><span class="n">MaternCorr</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">/</span><span class="n">r</span> <span class="p">)</span>

<span class="c1"># Plot covariances</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covSPDE</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;SPDE&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Covariance between point 0 and all other&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covMatern</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Matern&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1s3bIO_zjtRxuNvCWlWHUkjEQCV5YBBi6"><img alt="https://drive.google.com/uc?export=view&amp;id=1s3bIO_zjtRxuNvCWlWHUkjEQCV5YBBi6" src="https://drive.google.com/uc?export=view&amp;id=1s3bIO_zjtRxuNvCWlWHUkjEQCV5YBBi6" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1nw1mZNxJ2GFTz9iTuEmYE5IVPZXDgeqN"><img alt="https://drive.google.com/uc?export=view&amp;id=1nw1mZNxJ2GFTz9iTuEmYE5IVPZXDgeqN" src="https://drive.google.com/uc?export=view&amp;id=1nw1mZNxJ2GFTz9iTuEmYE5IVPZXDgeqN" style="width: 49%;" /></a>
<p>It is clear from this picture that the boundary artifacts have an impact on the corresponding Gaussian random field.
In the left figure we see the covariances between the point at the left boundary of the unit interval and all other nodal points.
Here, the variance is greatly overestimated by the SPDE approximation. In the right figure we see the covariance between the point at 0.601 again.
Without the mesh extension we see the boundary artifacts in the increased covariance when approaching the boundaries.</p>
<p>As can be seen, a Neumann boundary condition will overshoot the true covariance; making correlation ranges longer than intended.
On the other hand, a Dirichlet condition will undershoot it; making the correlation smaller than intended.
This gives a rationale for why a Robin condition can mitigate the boundary artifacts since it is a mixture between a Dirichlet condition (when both 'a' and 'b' are both large) and a Neumann condition (when 'a' is zero).</p>
<p>Before leaving the boundary conditions, let us just demonstrate the difference between the homogeneous Dirichlet and the Robin condition, when 'a' is  tuned for this particular example (setting <span class="math notranslate nohighlight">\(a = -0.26\)</span>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Dirichlet boundary condition</span>
<span class="n">BCDirichlet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
<span class="n">BCDirichlet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Create Robin boundary condition</span>
<span class="n">BCRobin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="n">BCRobin</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Association with constant</span>
<span class="n">BCRobin</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.26</span> <span class="c1"># Association with function</span>
<span class="c1"># Update new fem model</span>
<span class="n">fem5</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">BCDirichlet</span> <span class="o">=</span> <span class="n">BCDirichlet</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span> <span class="p">)</span>

<span class="n">temp</span> <span class="o">=</span> <span class="mi">300</span>

<span class="c1"># Compute covariance</span>
<span class="n">referenceNode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">referenceNode</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">covSPDE</span> <span class="o">=</span> <span class="n">fem5</span><span class="o">.</span><span class="n">multiplyWithCovariance</span><span class="p">(</span> <span class="n">referenceNode</span> <span class="p">)</span>

<span class="c1"># Compare with actual matern covariance</span>
<span class="kn">from</span> <span class="nn">fieldosophy.GRF</span> <span class="kn">import</span> <span class="n">GRF</span>
<span class="n">covMatern</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">GRF</span><span class="o">.</span><span class="n">MaternCorr</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">temp</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">/</span><span class="n">r</span> <span class="p">)</span>

<span class="c1"># Plot covariances</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covSPDE</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;SPDE&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">temp</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Covariance between point 0.601 and all other&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">mesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covMatern</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Matern&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=19Zj-wqFqE_VI0s2gLascacIi5pnz4AQJ"><img alt="https://drive.google.com/uc?export=view&amp;id=19Zj-wqFqE_VI0s2gLascacIi5pnz4AQJ" class="align-center" src="https://drive.google.com/uc?export=view&amp;id=19Zj-wqFqE_VI0s2gLascacIi5pnz4AQJ" style="width: 80%;" /></a>
<p>Here, the left boundary has a homogeneous Dirichlet condition while the right boundary has the suggested Robin condition (<span class="math notranslate nohighlight">\(a=-0.26, b=0\)</span>).
When comparing the covariance between all points and the point at 0.601, no boundary artifact is visible at the right side while the left side undershoots.
This is important since the point 0.601 is about 1 x <span class="math notranslate nohighlight">\(r\)</span> away from the right boundary but 1.5 x <span class="math notranslate nohighlight">\(r\)</span> from the left boundary.
So remember, always use the Robin condition in order reduce the number of nodes needed in the mesh extension; it becomes even more important when working in higher dimensions.</p>
</div>
<div class="section" id="conditional-distributions">
<h2>Conditional distributions<a class="headerlink" href="#conditional-distributions" title="Permalink to this headline">¶</a></h2>
<p>One of the most powerful properties of probabilistic modeling is the ability to acquire conditional distributions.
That is, acquiring the random field given that data has been observed at some locations.</p>
<p>We saw earlier how the Dirichlet boundary condition could be enforced also in the interior of the spatial domain.
This is one way of conditioning the random field, i.e., when knowing the value at some nodal points we can use those values as Dirichlet conditions to acquire a random field that includes the extra information we got from our data.
However, this only work properly when <span class="math notranslate nohighlight">\(\beta=1\)</span> and the observed values are at nodal points.
Although nodal points can be inserted in the exact locations of observations, this become more complicated if observation points differ between different replicates.</p>
<p>Often there are some additive noise to an observations. One speaks about the random field being a <em>latent model</em> that is not observed directly.
Instead, the observations are the latent model with some &quot;noise&quot; added. This noise is typically modeled as independent between observations.
Fieldosophy allows for conditioning given such an additive noise model,</p>
<div class="math notranslate nohighlight">
\[Y_i = X(\boldsymbol{s}_i) + \epsilon_i, \boldsymbol{s}_i \in \mathcal{D}.\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\{Y_i\}_i\)</span> are the &quot;measurement&quot; random variables at locations <span class="math notranslate nohighlight">\(\boldsymbol{s}_i\)</span>.
These random variables are dependent through the random field, <span class="math notranslate nohighlight">\(X\)</span>, but also has their independent noise, <span class="math notranslate nohighlight">\(\epsilon_i\)</span>.</p>
<p>In a typical application we are not interested in the observational noise, <span class="math notranslate nohighlight">\(\epsilon_i\)</span>, which typically depend on imperfections in the measurement equipment.
Instead, we are interested in modeling the actual process which the measurements try to observe at some points in space.
That is, we are interested in the random field or in a realization of the random field.
This scenario can be considered as a Bayesian analysis. We have our prior (the random field model), our likelihood (the distribution of <span class="math notranslate nohighlight">\(Y\)</span> given <span class="math notranslate nohighlight">\(X\)</span>), and we are interested in our posterior (<span class="math notranslate nohighlight">\(X\)</span> given Y).
Fieldosophy allow for computing these posterior random fields using the function 'cond' in the FEM class (given that the noise distribution is Gaussian).</p>
<p>Assume that we have the FEM model with the extended mesh and we have measurements at points 0.2 and 0.9.
The measured values were 2 and -1. We also know that the first measurement was made with a noise variance of 0.3 while the second measurement was made with a noise variance of 0.05.
We can then acquire the posterior random field.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set points of measurement</span>
<span class="n">condPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.9</span> <span class="p">]</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># Get observation matrix for these points</span>
<span class="n">condObsMat</span> <span class="o">=</span> <span class="n">fem4</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getObsMat</span><span class="p">(</span> <span class="n">condPoints</span> <span class="p">)</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
<span class="c1"># Set conditional values</span>
<span class="n">condVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]</span> <span class="p">)</span>
<span class="c1"># Set measurement noise</span>
<span class="n">sigmaEps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]))</span>
<span class="c1"># Compute conditional distribution</span>
<span class="n">condDistr</span> <span class="o">=</span> <span class="n">fem4</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">condVal</span><span class="p">,</span> <span class="n">condObsMat</span><span class="p">,</span> <span class="n">sigmaEps</span> <span class="o">=</span> <span class="n">sigmaEps</span><span class="p">)</span>
</pre></div>
</div>
<p>Before continuing, let us look at the first two rows above. What is hapening there is that we define two points to &quot;look at&quot;.
We then generate an &quot;observation matrix&quot; for those points using the command 'getObsMat' from the 'fieldosophy.mesh.Mesh' class.
An observation matrix maps nodal point values to the value at the given points.
This is possible since our FEM representation assumes picewise linear basis functions.
It is therefore possible to map values at the nodal points to corresponding values at any points in the interior of the mesh using a linear transformation.</p>
<p>The next lines defines the values at the measurement points as well as the standard deviation of their noise processes.
The final line of code then generates 'condDistr', which is a FEM object just as the original random field, 'fem4'.
That means that we will be able to perform the same operations on it as on 'fem4'.</p>
<p>Before plotting the posterior random field, remember that we are only interested in the unit interval.
Our mesh is extended to [-0.4,1.4] due to boundary effects but we only care about what is hapening on [0,1].
Just as with the measurement points, we can define which locations we want to &quot;look&quot; at.
Let us for now consider 100 points evenly distributed on the unit interval.
We can define an &quot;observation matrix&quot; for these as well.
Let us do that and then generate five realizations of the posterior random field as well as ploting the posterior mean and posterior marginal 90% prediction interval.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define analysis points on the unit interval</span>
<span class="n">anPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># Get observation matrix for analysis points</span>
<span class="n">anObsMat</span> <span class="o">=</span> <span class="n">fem4</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getObsMat</span><span class="p">(</span> <span class="n">anPoints</span> <span class="p">)</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
<span class="c1"># Get posterior mean mean at analysis points</span>
<span class="n">condMean</span> <span class="o">=</span> <span class="n">anObsMat</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="o">*</span> <span class="n">condDistr</span><span class="o">.</span><span class="n">mu</span>
<span class="c1"># Generate from the posterior random field and get values at analysis points</span>
<span class="n">condZ</span> <span class="o">=</span> <span class="n">anObsMat</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="o">*</span> <span class="n">condDistr</span><span class="o">.</span><span class="n">generateRandom</span><span class="p">(</span> <span class="mi">5</span> <span class="p">)</span>
<span class="c1"># Get covariance matrix for posterior Gaussian random field at analysis points</span>
<span class="n">condVar</span> <span class="o">=</span> <span class="n">anObsMat</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="o">*</span> <span class="n">condDistr</span><span class="o">.</span><span class="n">multiplyWithCovariance</span><span class="p">(</span> <span class="n">anObsMat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span> <span class="p">)</span>
<span class="c1"># Use only the variances, i.e., the diagonal of the covariance matrix</span>
<span class="n">condVar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">condVar</span><span class="p">)</span>

<span class="c1"># Plot conditional distribution</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">anPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">condZ</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Realization 1&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">anPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">condZ</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Realization 2&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">anPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">condZ</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Realization 3&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">anPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">condZ</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Realization 4&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">anPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">condZ</span><span class="p">[:,</span><span class="mi">4</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Realization 5&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">anPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">condMean</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Mean&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">condPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">condVal</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Measurements&quot;</span> <span class="p">)</span>

<span class="c1"># Plot conditional marginal 90% prediction interval</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span> <span class="n">anPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> \
     <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">condMean</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">condVar</span><span class="p">)</span> <span class="p">),</span> \
     <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">condMean</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">condVar</span><span class="p">)</span> <span class="p">),</span> <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Uncertainty&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1bO3AwCmdPVI48H7xq7oEkaIp6L0teOa-"><img alt="https://drive.google.com/uc?export=view&amp;id=1bO3AwCmdPVI48H7xq7oEkaIp6L0teOa-" class="align-center" src="https://drive.google.com/uc?export=view&amp;id=1bO3AwCmdPVI48H7xq7oEkaIp6L0teOa-" style="width: 80%;" /></a>
<p>The green region is the marginal 90% prediction interval, i.e., looking at only one location, there is a 90% probability that the value at this point will be inside the green inteval.
Remember that the green region should be interpreted marginally, i.e., for each point by itself.
If one realization happens to have a point outside of the green region, the probability that a point close to it will be outside of the green region is much higher than 10%.</p>
<p>As can be seen from the green region, close to the measured locations the variability is lower, i.e., the prediction interval is more narrow.
The variability then increases as points gets further away from the measured points.
We can see the same with the mean function that is very close to the measured values but then moves towards 0, since the original random field was centered.
Also the five realizations from the posterior random field show how the variability increases further away from the measurement locations.</p>
<p>It should be added that one can condition on more than one replicate by letting 'condVal' be a matrix where the columns represent different replicates while the rows still represents different locations.</p>
</div>
<div class="section" id="likelihood-based-inference">
<h2>Likelihood based inference<a class="headerlink" href="#likelihood-based-inference" title="Permalink to this headline">¶</a></h2>
<p>The likelihood function is important in statistics.
It can be used for several things, e.g., to estimate parameters through the maximum likelihood method, model validation through likelihood-ratio tests, or in Bayesian statistics, for instance to calculate acceptance ratios in Markov chain Monte-Carlo algorithms.</p>
<p>Fieldosophy allow computing the logarithm of the likelihood of a FEM object using the 'loglik' function.
Let us use the measurements from the former section and compute the log-likelihood function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">logLik</span> <span class="o">=</span> <span class="n">fem4</span><span class="o">.</span><span class="n">loglik</span><span class="p">(</span> <span class="n">condVal</span><span class="p">,</span> <span class="n">condObsMat</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(),</span> <span class="n">sigmaEps</span><span class="o">=</span><span class="n">sigmaEps</span><span class="p">)</span>
</pre></div>
</div>
<p>Giving a value of <span class="math notranslate nohighlight">\(-3.86\)</span>.</p>
<p>A high value of the likelihood (and therefore also of the log-likelihood) indicates that the model explain the observed data well.
However, one can only talk about high and low values in relative terms since the value of the likelihood depend strongly on the observed values.
Therefore, as an example, let us create a model which is identical to 'fem4' in every way except that it has a mean function that is equal to the posterior mean.
Hence, this model should have a higher likelihood than 'fem4' since it is more probable that it would generate the &quot;measured&quot; data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Robin boundary condition</span>
<span class="n">BCRobin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="n">BCRobin</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Association with constant</span>
<span class="n">BCRobin</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.26</span> <span class="c1"># Association with function</span>
<span class="c1"># Create FEM object</span>
<span class="n">femLoglik</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">extendedMesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">condDistr</span><span class="o">.</span><span class="n">mu</span> <span class="p">)</span>

<span class="c1"># compute</span>
<span class="n">logLik2</span> <span class="o">=</span> <span class="n">femLoglik</span><span class="o">.</span><span class="n">loglik</span><span class="p">(</span> <span class="n">condVal</span><span class="p">,</span> <span class="n">condObsMat</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(),</span> <span class="n">sigmaEps</span><span class="o">=</span><span class="n">sigmaEps</span><span class="p">)</span>
</pre></div>
</div>
<p>The value of 'loglik2' is <span class="math notranslate nohighlight">\(-3.27\)</span> and hence higher than 'loglik', as expected. The above code also show how we can define a non-centered GRF model by the 'mu' parameter. One simply supply an array with the mean value for each node.</p>
</div>
<div class="section" id="estimate-parameters">
<h2>Estimate parameters<a class="headerlink" href="#estimate-parameters" title="Permalink to this headline">¶</a></h2>
<p>We can also use the log-likelihood function to estimate the parameters of our random field model using the maximum likelihood method.
Let us first create a new random field model with a different range and smoothness, and with some measurement noise.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Robin boundary condition</span>
<span class="n">BCRobin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="n">BCRobin</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Association with constant</span>
<span class="n">BCRobin</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.26</span> <span class="c1"># Association with function</span>

<span class="c1"># Define new Matérn random field</span>
<span class="n">rTrue</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># Set correlation range (range for which two points have approximately 0.13 correlation)</span>
<span class="n">nuTrue</span> <span class="o">=</span> <span class="mf">2.5</span>   <span class="c1"># Set smoothness (basically the Hölder constant of realizations)</span>
<span class="c1"># Create MaternFEM object</span>
<span class="n">femTrue</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">extendedMesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">rTrue</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nuTrue</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="p">)</span>

<span class="c1"># Generate 100 realizations</span>
<span class="n">ZTrue</span> <span class="o">=</span> <span class="n">femTrue</span><span class="o">.</span><span class="n">generateRandom</span><span class="p">(</span> <span class="mi">100</span> <span class="p">)</span>

<span class="c1"># Define 20 &quot;measurement points&quot; randomly over the unit interval</span>
<span class="n">measPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># Get observation matrix</span>
<span class="n">measObsMat</span> <span class="o">=</span> <span class="n">femTrue</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">getObsMat</span><span class="p">(</span> <span class="n">measPoints</span> <span class="p">)</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
<span class="c1"># Get observations to measurement points</span>
<span class="n">ZMeas</span> <span class="o">=</span> <span class="n">measObsMat</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="o">*</span> <span class="n">ZTrue</span>
<span class="c1"># Define measurement standard deviation (the same for all points)</span>
<span class="n">sigmaEpsTrue</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="c1"># Add measurement noise</span>
<span class="n">ZMeas</span> <span class="o">=</span> <span class="n">ZMeas</span> <span class="o">+</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span> <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">sigmaEpsTrue</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">20</span><span class="o">*</span><span class="mi">100</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
</pre></div>
</div>
<p>To get a feeling for the random field, lets observe the values of 'Z' and 'ZMeas' for two different realizations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="c1"># Plot realizations</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ZTrue</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">measPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ZMeas</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;ZMeas&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Realization 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="c1"># Plot realizations</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ZTrue</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">measPoints</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ZMeas</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;ZMeas&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Realization 2&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1pEbexBXK9OY6xo8WNfXGWcpDbaB7nP3M"><img alt="https://drive.google.com/uc?export=view&amp;id=1pEbexBXK9OY6xo8WNfXGWcpDbaB7nP3M" src="https://drive.google.com/uc?export=view&amp;id=1pEbexBXK9OY6xo8WNfXGWcpDbaB7nP3M" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1GDGYmU_ZryOscGNliJHl9t2woC5-y92i"><img alt="https://drive.google.com/uc?export=view&amp;id=1GDGYmU_ZryOscGNliJHl9t2woC5-y92i" src="https://drive.google.com/uc?export=view&amp;id=1GDGYmU_ZryOscGNliJHl9t2woC5-y92i" style="width: 49%;" /></a>
<p>Next, we do only want to search for the parameters in a reasonable range. Let us only look for a smoothness in between [1, 4], a correlation range in between [0.1, 1], and a noise standard deviation in between [0.01, 1].
Remember that we want the correlation range to be no smaller than 5 times the minimum nodal distance and no longer than the mesh extension.
At the same time we want to use as few nodes as possible.
One of the benefits with the observation matrices is that we remove the direct connection between points we are intersted in and nodal points.
This can enhance performance since the mesh can often be coarser due to this, compared to if we could only model values at the nodal points.
Before we had 500 points on the unit interval.
We do not need that many nodes and when optimizing we want speed so let us make a new mesh.
Say that we do not want the nodal distance to be longer than a seventh of the correlation range in order to keep a good approximation.
We know that the smallest range we will allow is 0.1 and therefore we should have <span class="math notranslate nohighlight">\(7\cdot 10 = 70\)</span> nodes on the unit interval.
At the same time we want to search for the correlation range in an interval with a maximum of 1. Hence, we want to extend by 1 on each side.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create new mesh</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">70</span> <span class="o">*</span> <span class="mi">3</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">simplices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">mesher</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">simplices</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span> <span class="p">)</span>
<span class="c1"># Create observation matrix for points</span>
<span class="n">obsMat</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">getObsMat</span><span class="p">(</span> <span class="n">measPoints</span> <span class="p">)</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
</pre></div>
</div>
<p>We can now define our initial guess of the true random field on this new mesh. Let us assumed the same parameters as before as our initial guess.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the Matérn random field</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># Set correlation range (range for which two points have approximately 0.13 correlation)</span>
<span class="n">nu</span> <span class="o">=</span> <span class="mf">1.5</span>   <span class="c1"># Set smoothness (basically the Hölder constant of realizations)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span>   <span class="c1"># Set standard deviation</span>
<span class="n">sigmaEps</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># Set the measurement noise standard deviation</span>
<span class="n">femNew</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">MaternFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">r</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="p">)</span>
</pre></div>
</div>
<p>Compare the log-likelihood function of the two models.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># loglik</span>
<span class="n">loglik</span> <span class="o">=</span> <span class="n">femNew</span><span class="o">.</span><span class="n">loglik</span><span class="p">(</span> <span class="n">ZMeas</span><span class="p">,</span> <span class="n">obsMat</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(),</span> <span class="n">sigmaEps</span><span class="o">=</span><span class="n">sigmaEps</span> <span class="p">)</span>
<span class="n">loglik2</span> <span class="o">=</span> <span class="n">femTrue</span><span class="o">.</span><span class="n">loglik</span><span class="p">(</span> <span class="n">ZMeas</span><span class="p">,</span> <span class="n">measObsMat</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(),</span> <span class="n">sigmaEps</span><span class="o">=</span><span class="n">sigmaEpsTrue</span> <span class="p">)</span>
</pre></div>
</div>
<p>The values were, -32.59 for the initial guess and -23.20 for the true model. Obviously the true model has a higher log-likelihood.</p>
<p>We want to make use of a numerical optimizer to maximize the log-likelihood. It is generally easier to optimize over an unconstrained parameter space.
Therefore, we define a transformation of the parameters such that the search range becomes the real line.
Let us define a sigmoid function and its inverse through the CDF and quantile function of the logistic probability distribution.
Hence, we can map [1,4], [0.1,1], and [0.01, 1] to the real line with a well-behaving function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">optimTrans</span><span class="p">(</span> <span class="n">x</span> <span class="p">):</span>
    <span class="c1"># Function for mapping nu and r back to original range</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">3.0</span> <span class="o">+</span> <span class="mf">1.0</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.9</span> <span class="o">+</span> <span class="mf">0.1</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.99</span> <span class="o">+</span> <span class="mf">0.01</span>

    <span class="k">return</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">optimTransInv</span><span class="p">(</span> <span class="n">x</span> <span class="p">):</span>
    <span class="c1"># Function for mapping nu and r to an unbounded space</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.1</span> <span class="p">)</span> <span class="o">/</span> <span class="mf">0.9</span> <span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.01</span> <span class="p">)</span> <span class="o">/</span> <span class="mf">0.99</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
<p>Now we can perform the numerical maximization of the log-likelihood function using 'scipy.optimize.minimize' and defining the cost function as the negative of the log-likelihood.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">optimFunc</span><span class="p">(</span> <span class="n">x</span> <span class="p">):</span>
    <span class="c1"># function to optmize, in this case the log-likelihood after transformation</span>

    <span class="c1"># Transform from unconstrained to constrained value</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">optimTrans</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span>
    <span class="n">nuCur</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rCur</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sigmaEpsCur</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Update current system</span>
    <span class="n">femNew</span><span class="o">.</span><span class="n">updateSystem</span><span class="p">(</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="n">rCur</span><span class="p">},</span> <span class="n">nu</span><span class="o">=</span><span class="n">nuCur</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span> <span class="p">)</span>
    <span class="c1"># Compute log-lik</span>
    <span class="n">logLik</span> <span class="o">=</span> <span class="n">femNew</span><span class="o">.</span><span class="n">loglik</span><span class="p">(</span> <span class="n">ZMeas</span><span class="p">,</span> <span class="n">obsMat</span><span class="o">.</span><span class="n">tocsc</span><span class="p">(),</span> <span class="n">sigmaEps</span><span class="o">=</span><span class="n">sigmaEpsCur</span><span class="p">)</span>
    <span class="c1"># Return minus log-likelihood</span>
    <span class="k">return</span> <span class="o">-</span> <span class="n">logLik</span>


<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

<span class="c1"># Set initial value</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">optimTransInv</span><span class="p">(</span> <span class="p">[</span> <span class="n">nu</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">sigmaEps</span> <span class="p">]</span> <span class="p">)</span>
<span class="c1"># Optimize (&quot;BFGS&quot;)</span>
<span class="c1"># resultOptim = optimize.minimize( optimFunc, x0, method=&#39;BFGS&#39;, options={&#39;disp&#39;: True, &quot;maxiter&quot;:20, &quot;gtol&quot;: 1e-1} )</span>
<span class="n">resultOptim</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span> <span class="n">optimFunc</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;maxiter&quot;</span><span class="p">:</span><span class="mi">200</span><span class="p">}</span> <span class="p">)</span>
<span class="c1"># Get result</span>
<span class="n">nuEst</span><span class="p">,</span> <span class="n">rEst</span><span class="p">,</span> <span class="n">sigmaEpsEst</span> <span class="o">=</span> <span class="n">optimTrans</span><span class="p">(</span> <span class="n">resultOptim</span><span class="o">.</span><span class="n">x</span> <span class="p">)</span>
</pre></div>
</div>
<p>The parameters were estimated to [nu = 3.6, r = 0.19, and sigmaEps = 0.20 ] as compared to [nu = 2.5, r = 0.2, and sigmaEps = 0.2 ].
The correlation range and noise standard deviation was almost exact while the smoothness parameter was a little bit off.
It should be noted that for large values of <span class="math notranslate nohighlight">\(\nu\)</span>, a small change in the smoothness does not change the covariance function significantly.
This is intuitive if you consider that <span class="math notranslate nohighlight">\(\nu\)</span> correspond to the Hölder constant of the realizations.
It is hard to see if a function is differentiable up to the fourth order or just the third order, while a smoothness of 1 is significantly different than 0.5.
Let us therefore compare the two Matérn correlations, the true and the estimated, to see how much difference it really makes to have <span class="math notranslate nohighlight">\(\nu=3.6\)</span> instead of <span class="math notranslate nohighlight">\(\nu = 2.5\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="c1"># Plot realizations</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="p">(</span><span class="n">GRF</span><span class="o">.</span><span class="n">MaternCorr</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nuEst</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nuEst</span><span class="p">)</span><span class="o">/</span><span class="n">rEst</span> <span class="p">)</span> <span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Estimated&quot;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="p">(</span><span class="n">GRF</span><span class="o">.</span><span class="n">MaternCorr</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nuTrue</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nuTrue</span><span class="p">)</span><span class="o">/</span><span class="n">rTrue</span> <span class="p">)</span> <span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1CaZi6iLEHjyisll3bc8e2nwfWH8U27E3"><img alt="https://drive.google.com/uc?export=view&amp;id=1CaZi6iLEHjyisll3bc8e2nwfWH8U27E3" class="align-center" src="https://drive.google.com/uc?export=view&amp;id=1CaZi6iLEHjyisll3bc8e2nwfWH8U27E3" style="width: 80%;" /></a>
<p>As can be seen, for smoothness values as large as 2.5 it is no visible difference to a value of 3.6. The log-likelihood of the estimated model is <span class="math notranslate nohighlight">\(-23.01\)</span>, which is actually a little bit higher than the true model.</p>
</div>
<div class="section" id="constructing-the-non-stationary-model">
<h2>Constructing the non-stationary model<a class="headerlink" href="#constructing-the-non-stationary-model" title="Permalink to this headline">¶</a></h2>
<p>Fieldosophy was created mainly to focus on modeling non-stationary random fields using the SPDE-approach.
So far in this tutorial we have only been looking at the regular Matérn model.
However, the non-stationary model is an extension of the Matérn model derived from extending the stochastic partial differential equation of the Matérn covariance function.
Hence, since we now know the basics of modeling the Matérn model in one dimension using Fieldosophy, going non-stationary is a small step.</p>
<p>The non-stationary models are defined using the SPDE of <a class="reference internal" href="introduction.html#equation-hildemanspde">(3)</a>.
As such, they are defined by the metric tensor (the <span class="math notranslate nohighlight">\(G\)</span> matrix).
One intuitive way of looking at the non-stationary models is to remember that <span class="math notranslate nohighlight">\(G\)</span> is a matrix which eigenvalues explains how much space should be compressed or expanded in order to get a Matérn covariance with <span class="math notranslate nohighlight">\(\kappa = 1\)</span> (in the direction of the corresponding eigenvector).
Hence, if <span class="math notranslate nohighlight">\(G\)</span> was a constant matrix with an eigenvalue of <span class="math notranslate nohighlight">\(\frac{\sqrt{8\nu}}{r}\)</span>, this would mean that the correlation range in the direction of the corresponding eigenvector would be <span class="math notranslate nohighlight">\(r\)</span>.
This is easy to see if you remember that the correlation range is <span class="math notranslate nohighlight">\(\sqrt{8\nu}\)</span> when <span class="math notranslate nohighlight">\(\kappa = 1\)</span>, and that <span class="math notranslate nohighlight">\(\kappa\)</span> is inversely proportional to the correlation range.
Hence, an alternative way of creating the Matérn field of 'fem4' is by using the 'FEM.nonStatFEM' function of 'fieldosophy.GRF'.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mapFEMParamsToG</span><span class="p">(</span> <span class="n">params</span> <span class="p">):</span>

    <span class="n">GInv</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">]</span>
    <span class="n">logGSqrt</span> <span class="o">=</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="n">GInv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">logGSqrt</span><span class="p">,</span> <span class="n">GInv</span><span class="p">)</span>

<span class="c1"># Create FEM object</span>
<span class="n">nonstatfem</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">nonStatFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">extendedMesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;r&quot;</span><span class="p">:</span><span class="n">r</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span><span class="n">mapFEMParamsToG</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span> <span class="p">)</span>
</pre></div>
</div>
<p>When defining the random field of class 'FEM.nonStatFEM', the 'childParams' dictionary should hold all parameters needed to construct G.
One can define a function that assembles these paramers and returns the inverse of G and the logarithm of the square root of the determinant of G.
Here, 'GInv' should be a list, each list element corresponding to an element in the G-matrix (flattened to one dimension).
The elements of 'Ginv', as well as 'logGSqrt', operate on an array the size of the number of simplices in the mesh.
Hence, they either have to be scalars or arrays with size the number of simplices in the mesh.
In the stationary case they can be scalars since we want to use the same value for all simplices.
However, when we actually want to define a non-stationary model we want the values to vary with the simplices.</p>
<p>Let us continue with our extended mesh from before, 'extendedMesh'.
This mesh was created as to allow for a correlation range of 0.4.
When we speak about a non-stationary model the concept of correlation range become somewhat confusing.
We earlier defined correlation range as the distance at which two points have a correlation of 0.1 (or in our parameterization 0.13).
For a non-stationary model such a definition does not make sense.
Instead, we will now define a non-stationary model based on what we can call <em>local correlation ranges</em>.
That is, we manipulate the <span class="math notranslate nohighlight">\(G\)</span>-matrix for each simplex using <span class="math notranslate nohighlight">\(r\)</span>, just as above. However, <span class="math notranslate nohighlight">\(r\)</span> will vary between different simplices.</p>
<p>Let us in this example assume that we want short local correlation ranges close to 0 and long correlation ranges close to 1.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute the middle point in each simplex</span>
<span class="n">simplexMeanPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">triangles</span> <span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
<span class="c1"># Use simplixes middle points to set the local correlation range</span>
<span class="n">rLocal</span> <span class="o">=</span> <span class="n">simplexMeanPoints</span> <span class="o">-</span> <span class="mf">0.1</span>
<span class="c1"># Set the extensions to the original value of 0.4</span>
<span class="n">rLocal</span><span class="p">[</span><span class="n">simplexMeanPoints</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">rLocal</span><span class="p">[</span><span class="n">simplexMeanPoints</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">=</span> <span class="mf">0.4</span>
</pre></div>
</div>
<p>The last two rows just make sure that the extension region still have the old value of 0.4.
This to make sure that we do not get boundary artifacts close to the right extension region (which would otherwise have had longer local correlation ranges), and that we do not get infeasible or too small correlation ranges for our mesh on the left extension region.</p>
<p>Let us now define the non-stationary model using these local correlation ranges instead.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create FEM object</span>
<span class="n">nonstatfem</span> <span class="o">=</span> <span class="n">FEM</span><span class="o">.</span><span class="n">nonStatFEM</span><span class="p">(</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">extendedMesh</span><span class="p">,</span> <span class="n">childParams</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;r&quot;</span><span class="p">:</span><span class="n">rLocal</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span><span class="n">mapFEMParamsToG</span><span class="p">},</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">BCRobin</span> <span class="o">=</span> <span class="n">BCRobin</span> <span class="p">)</span>
</pre></div>
</div>
<p>As can be seen, we could reuse our 'mapFEMParamsToG' function since it also works with array input.</p>
<p>To understand what this model is doing let us plot the local correlation ranges agains the middle value of each simplex and compare this with the covariance between the point at 0.5 and all other points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get covariance between the point in the middle of the interval and all other points</span>
<span class="n">referenceNode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">extendedMesh</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">referenceNode</span><span class="p">[</span><span class="mi">450</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">covSPDE</span> <span class="o">=</span> <span class="n">nonstatfem</span><span class="o">.</span><span class="n">multiplyWithCovariance</span><span class="p">(</span> <span class="n">referenceNode</span> <span class="p">)</span>
<span class="n">covSPDE</span> <span class="o">=</span> <span class="n">nonstatfem</span><span class="o">.</span><span class="n">multiplyWithCovariance</span><span class="p">(</span> <span class="n">referenceNode</span> <span class="p">)</span>
<span class="c1"># Compare with actual matern covariance</span>
<span class="n">covMatern</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">GRF</span><span class="o">.</span><span class="n">MaternCorr</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">nu</span> <span class="o">=</span> <span class="n">nu</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">/</span><span class="n">r</span> <span class="p">)</span>


<span class="c1"># Plot covariances</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covSPDE</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;SPDE&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Covariance between point 0.5 and all other&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">extendedMesh</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">covMatern</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Matern&quot;</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="c1"># Plot non-stationarity</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="n">simplexMeanPoints</span><span class="p">,</span> <span class="n">rLocal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span> <span class="s2">&quot;Local correlation ranges&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1lot0WEDwcI5nHml7kvYUpSzOWq_v3jZA"><img alt="https://drive.google.com/uc?export=view&amp;id=1lot0WEDwcI5nHml7kvYUpSzOWq_v3jZA" src="https://drive.google.com/uc?export=view&amp;id=1lot0WEDwcI5nHml7kvYUpSzOWq_v3jZA" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1RLqfOr9B6wiO0pYWYzJ4pTHezs0kCwp6"><img alt="https://drive.google.com/uc?export=view&amp;id=1RLqfOr9B6wiO0pYWYzJ4pTHezs0kCwp6" src="https://drive.google.com/uc?export=view&amp;id=1RLqfOr9B6wiO0pYWYzJ4pTHezs0kCwp6" style="width: 49%;" /></a>
<p>As seen, the covariance on the left side of 0.5 drops off much faster than the original Matérn covariance.
On the right side we see the opposite.</p>
<p>Let us also plot two realization to see what type of behavior this actually correspond to among realizations from this non-stationary random field.</p>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1JZyUpvzZWcQn9iNnZw3t-X-tz1aDEQhG"><img alt="https://drive.google.com/uc?export=view&amp;id=1JZyUpvzZWcQn9iNnZw3t-X-tz1aDEQhG" src="https://drive.google.com/uc?export=view&amp;id=1JZyUpvzZWcQn9iNnZw3t-X-tz1aDEQhG" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="https://drive.google.com/uc?export=view&amp;id=1RHUE1DBvULml0vuMF87VKPILIqDDQ8CE"><img alt="https://drive.google.com/uc?export=view&amp;id=1RHUE1DBvULml0vuMF87VKPILIqDDQ8CE" src="https://drive.google.com/uc?export=view&amp;id=1RHUE1DBvULml0vuMF87VKPILIqDDQ8CE" style="width: 49%;" /></a>
<p>On the left side we see more dramatic behavior since the original scales are compressed to a shorter region (0.1 instead of 0.4).
On the right side we see slowly varying ups and downs, since here, the original scales are instead elongated.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial: 1D SPDE modeling using Fieldosophy</a><ul>
<li><a class="reference internal" href="#constructing-the-mesh">Constructing the mesh</a></li>
<li><a class="reference internal" href="#constructing-a-matern-model">Constructing a Matérn model</a></li>
<li><a class="reference internal" href="#quality-of-fem-approximation-and-numerical-stability">Quality of FEM-approximation and numerical stability</a></li>
<li><a class="reference internal" href="#boundary-conditions">Boundary conditions</a></li>
<li><a class="reference internal" href="#extending-the-mesh-to-remove-boundary-artifacts">Extending the mesh to remove boundary artifacts</a></li>
<li><a class="reference internal" href="#computing-and-comparing-covariances">Computing and comparing covariances</a></li>
<li><a class="reference internal" href="#conditional-distributions">Conditional distributions</a></li>
<li><a class="reference internal" href="#likelihood-based-inference">Likelihood based inference</a></li>
<li><a class="reference internal" href="#estimate-parameters">Estimate parameters</a></li>
<li><a class="reference internal" href="#constructing-the-non-stationary-model">Constructing the non-stationary model</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorials.html"
                        title="previous chapter">Tutorials</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api_reference.html"
                        title="next chapter">Fieldosophy API</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tutorial1D.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api_reference.html" title="Fieldosophy API"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fieldosophy 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tutorials.html" >Tutorials</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Anders Gunnar Felix Hildeman.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>